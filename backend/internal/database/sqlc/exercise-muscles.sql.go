// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: exercise-muscles.sql

package sqlc

import (
	"context"
)

const createExerciseMuscle = `-- name: CreateExerciseMuscle :one
INSERT INTO exercise_muscles (
  exercise_id,
  muscle_id,
  involvement_level
) VALUES (
  $1,
  $2,
  $3
) RETURNING exercise_id, muscle_id, involvement_level
`

type CreateExerciseMuscleParams struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
}

func (q *Queries) CreateExerciseMuscle(ctx context.Context, arg CreateExerciseMuscleParams) (ExerciseMuscle, error) {
	row := q.db.QueryRowContext(ctx, createExerciseMuscle, arg.ExerciseID, arg.MuscleID, arg.InvolvementLevel)
	var i ExerciseMuscle
	err := row.Scan(&i.ExerciseID, &i.MuscleID, &i.InvolvementLevel)
	return i, err
}

const deleteAllExerciseMuscles = `-- name: DeleteAllExerciseMuscles :exec
DELETE FROM exercise_muscles
`

func (q *Queries) DeleteAllExerciseMuscles(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllExerciseMuscles)
	return err
}

const deleteExerciseMuscle = `-- name: DeleteExerciseMuscle :exec
DELETE FROM exercise_muscles 
WHERE exercise_id = $1 AND muscle_id = $2
`

type DeleteExerciseMuscleParams struct {
	ExerciseID int32
	MuscleID   int32
}

func (q *Queries) DeleteExerciseMuscle(ctx context.Context, arg DeleteExerciseMuscleParams) error {
	_, err := q.db.ExecContext(ctx, deleteExerciseMuscle, arg.ExerciseID, arg.MuscleID)
	return err
}

const exerciseMuscleExists = `-- name: ExerciseMuscleExists :one
SELECT EXISTS(
  SELECT 1 FROM exercise_muscles 
  WHERE exercise_id = $1 AND muscle_id = $2
)
`

type ExerciseMuscleExistsParams struct {
	ExerciseID int32
	MuscleID   int32
}

func (q *Queries) ExerciseMuscleExists(ctx context.Context, arg ExerciseMuscleExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, exerciseMuscleExists, arg.ExerciseID, arg.MuscleID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getExerciseMuscles = `-- name: GetExerciseMuscles :many
SELECT 
  em.exercise_id, em.muscle_id, em.involvement_level,
  e.exercise_name,
  m.muscle_name,
  m.muscle_group
FROM exercise_muscles em
JOIN exercises e ON em.exercise_id = e.exercise_id
JOIN muscles m ON em.muscle_id = m.muscle_id
WHERE em.exercise_id = $1
`

type GetExerciseMusclesRow struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
	ExerciseName     string
	MuscleName       string
	MuscleGroup      string
}

func (q *Queries) GetExerciseMuscles(ctx context.Context, exerciseID int32) ([]GetExerciseMusclesRow, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseMuscles, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMusclesRow
	for rows.Next() {
		var i GetExerciseMusclesRow
		if err := rows.Scan(
			&i.ExerciseID,
			&i.MuscleID,
			&i.InvolvementLevel,
			&i.ExerciseName,
			&i.MuscleName,
			&i.MuscleGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseMusclesByMuscleGroup = `-- name: GetExerciseMusclesByMuscleGroup :many
SELECT 
  em.exercise_id, em.muscle_id, em.involvement_level,
  e.exercise_name,
  m.muscle_name,
  m.muscle_group
FROM exercise_muscles em
JOIN exercises e ON em.exercise_id = e.exercise_id
JOIN muscles m ON em.muscle_id = m.muscle_id
WHERE m.muscle_group = $1
ORDER BY e.exercise_name
`

type GetExerciseMusclesByMuscleGroupRow struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
	ExerciseName     string
	MuscleName       string
	MuscleGroup      string
}

func (q *Queries) GetExerciseMusclesByMuscleGroup(ctx context.Context, muscleGroup string) ([]GetExerciseMusclesByMuscleGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseMusclesByMuscleGroup, muscleGroup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseMusclesByMuscleGroupRow
	for rows.Next() {
		var i GetExerciseMusclesByMuscleGroupRow
		if err := rows.Scan(
			&i.ExerciseID,
			&i.MuscleID,
			&i.InvolvementLevel,
			&i.ExerciseName,
			&i.MuscleName,
			&i.MuscleGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMuscleExercises = `-- name: GetMuscleExercises :many
SELECT 
  em.exercise_id, em.muscle_id, em.involvement_level,
  e.exercise_name,
  m.muscle_name,
  m.muscle_group
FROM exercise_muscles em
JOIN exercises e ON em.exercise_id = e.exercise_id
JOIN muscles m ON em.muscle_id = m.muscle_id
WHERE em.muscle_id = $1
`

type GetMuscleExercisesRow struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
	ExerciseName     string
	MuscleName       string
	MuscleGroup      string
}

func (q *Queries) GetMuscleExercises(ctx context.Context, muscleID int32) ([]GetMuscleExercisesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMuscleExercises, muscleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMuscleExercisesRow
	for rows.Next() {
		var i GetMuscleExercisesRow
		if err := rows.Scan(
			&i.ExerciseID,
			&i.MuscleID,
			&i.InvolvementLevel,
			&i.ExerciseName,
			&i.MuscleName,
			&i.MuscleGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryMusclesForExercise = `-- name: GetPrimaryMusclesForExercise :many
SELECT 
  m.muscle_name,
  m.muscle_group
FROM exercise_muscles em
JOIN muscles m ON em.muscle_id = m.muscle_id
WHERE em.exercise_id = $1 
AND em.involvement_level = 'Primary'
ORDER BY m.muscle_name
`

type GetPrimaryMusclesForExerciseRow struct {
	MuscleName  string
	MuscleGroup string
}

func (q *Queries) GetPrimaryMusclesForExercise(ctx context.Context, exerciseID int32) ([]GetPrimaryMusclesForExerciseRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryMusclesForExercise, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrimaryMusclesForExerciseRow
	for rows.Next() {
		var i GetPrimaryMusclesForExerciseRow
		if err := rows.Scan(&i.MuscleName, &i.MuscleGroup); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExerciseMuscles = `-- name: ListExerciseMuscles :many
SELECT 
  em.exercise_id, em.muscle_id, em.involvement_level,
  e.exercise_name,
  m.muscle_name,
  m.muscle_group
FROM exercise_muscles em
JOIN exercises e ON em.exercise_id = e.exercise_id
JOIN muscles m ON em.muscle_id = m.muscle_id
ORDER BY e.exercise_name, m.muscle_name
`

type ListExerciseMusclesRow struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
	ExerciseName     string
	MuscleName       string
	MuscleGroup      string
}

func (q *Queries) ListExerciseMuscles(ctx context.Context) ([]ListExerciseMusclesRow, error) {
	rows, err := q.db.QueryContext(ctx, listExerciseMuscles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExerciseMusclesRow
	for rows.Next() {
		var i ListExerciseMusclesRow
		if err := rows.Scan(
			&i.ExerciseID,
			&i.MuscleID,
			&i.InvolvementLevel,
			&i.ExerciseName,
			&i.MuscleName,
			&i.MuscleGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExerciseMuscle = `-- name: UpdateExerciseMuscle :one
UPDATE exercise_muscles 
SET involvement_level = $3
WHERE exercise_id = $1 AND muscle_id = $2
RETURNING exercise_id, muscle_id, involvement_level
`

type UpdateExerciseMuscleParams struct {
	ExerciseID       int32
	MuscleID         int32
	InvolvementLevel InvolvementLevelEnum
}

func (q *Queries) UpdateExerciseMuscle(ctx context.Context, arg UpdateExerciseMuscleParams) (ExerciseMuscle, error) {
	row := q.db.QueryRowContext(ctx, updateExerciseMuscle, arg.ExerciseID, arg.MuscleID, arg.InvolvementLevel)
	var i ExerciseMuscle
	err := row.Scan(&i.ExerciseID, &i.MuscleID, &i.InvolvementLevel)
	return i, err
}
